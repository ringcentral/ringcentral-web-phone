{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RingCentral WebPhone SDK","text":"<p>!!! info \"Migrate to Web Phone SDK 2.0\" This website is devoted to the latest version of the RingCentral Web Phone SDK, version 2.x. While we will continue to support 1.x, we will no longer be actively be maintaining it. If you are still using version 1.0, we recommend you migrate your application to the latest version.</p> <p>The RingCentral WebPhone SDK is a toolset for use within the context of a web browser. Developers use the SDK to build custom phone clients and CTIs from the ground up. The WebPhone SDK utilizes a user's credentials obtained independently through OAuth to place and receive phone calls.</p> <p>Once a call is connected and a session established, the WebPhone SDK can be used to manipulate that phone call in all the ways you would expect a device to be able to, including:</p> <ul> <li>answering and hanging up</li> <li>muting and unmuting</li> <li>placing or removing someone from hold</li> <li>transferring or merging calls</li> <li>starting, stopping and pausing a recording</li> <li>and so forth</li> </ul> <p>Furthermore, the WebPhone SDK can be combined with other SDKs to call the RingCentral REST API in order to create more advanced applications that leverage other data sources and APIs throughout the RingCentral ecosystem and beyond.</p>"},{"location":"#explore-a-live-demo-of-the-webphone-sdk","title":"Explore a live demo of the WebPhone SDK","text":"<ul> <li> Live demo</li> </ul> <p>Access a live demo of the WebPhone SDK. You will need to register an app and   obtain credentials first.</p> <p> Launch demo</p> <ul> <li> Source code</li> </ul> <p>Access, clone or fork the WebPhone SDK demo on Github to kick start the   development on your custom CTI.</p> <p> Explore the source code</p>"},{"location":"audio/","title":"Managed and changing audio devices","text":""},{"location":"audio/#audio-devices","title":"Audio Devices","text":"<p>By default, this SDK will use the default audio input device and output device available.</p>"},{"location":"audio/#change-default-devices","title":"Change default devices","text":"<p>If you would like to change the default audio input and output devices, you may create your own <code>DeviceManager</code> class:</p> <pre><code>import { DefaultDeviceManager } from 'ringcentral-web-phone/device-manager';\n\nclass MyDeviceManager extends DefaultDeviceManager {\n  public async getInputDeviceId(): Promise&lt;string&gt; {\n    return 'my-preferred-input-device-id';\n  }\n\n  public async getOutputDeviceId(): Promise&lt;string | undefined&gt; {\n    return 'my-preferred-output-device-id';\n  }\n}\n\n...\n\nconst deviceManager = new MyDeviceManager();\nconst webPhone = new WebPhone({ sipInfo, deviceManager });\n\n// or you can change it afterwards at any time:\n// webPhone.deviceManager = deviceManager;\n</code></pre> <p>To get all the devices available, please refer to MediaDevices: enumerateDevices() method.</p> <p>Please note that, changing <code>deviceManager</code> will only affect future calls. It won't change the device of ongoing calls.</p>"},{"location":"audio/#change-device-of-ongoing-calls","title":"Change device of ongoing calls","text":"<pre><code>await callSession.changeInputDevice(\"my-preferred-input-device-id\");\nawait callSession.changeOutputDevice(\"my-preferred-output-device-id\");\n</code></pre>"},{"location":"audio/#firefox","title":"firefox","text":"<p>Firefox doesn't support output device selection. Please use <code>undefined</code> as <code>outputDeviceId</code>.</p>"},{"location":"events/","title":"WebPhone SDK events","text":"<p>The WebPhoneSDK makes a number of events available to subscribe to. There are two categories of events:</p> <ul> <li>webPhone events</li> <li>callSession events</li> </ul>"},{"location":"events/#subscribing-to-events","title":"Subscribing to events","text":"<p>Subscribing to events is done using the <code>on</code> method as shown below.</p> <pre><code>webPhone.on(\"inboundCall\", (inboundCall: InboundCallSession) =&gt; {\n  // do something with the inbound call\n});\n</code></pre> <pre><code>callSession.on(\"disposed\", () =&gt; {\n  // do something when the call session is disposed\n});\n</code></pre>"},{"location":"events/#webphone-events","title":"WebPhone events","text":"Event Description <code>inboundCall</code> Triggered when a call is received. <code>outboundCall</code> Triggered when a call is placed."},{"location":"events/#callsession-events","title":"CallSession events","text":"Event Description <code>answered</code> Triggered when the call is answered. <code>disposed</code> For answered calls, this event is triggered when someone hangs up. For inbound calls, it is triggered if the caller hangs up or if the call is answered on another device. <code>inboundMessage</code> Triggered when you receive a SIP message. <code>outboundMessage</code> Triggered when a SIP message is sent. <code>ringing</code> This event does exist, but it is effectively implied by the existence of other events."},{"location":"events/answered/","title":"callSession.on('answered', callback)","text":"<p>Registers a callback to be invoked when a call is answered.</p> <p>The <code>answered</code> event is triggered when a call transitions from the ringing state to the connected state\u2014i.e., when the call is answered by the remote party.</p> <p>!!! warning \"Important Limitation: Due to the behavior of the underlying SIP infrastructure, this event behaves differently for inbound and outbound calls\"</p>"},{"location":"events/answered/#outbound-call-limitation","title":"Outbound call limitation","text":"<p>The SIP server responds with a 200 OK immediately after the INVITE is sent, regardless of whether the remote party has actually answered. This means the answered event is triggered immediately after initiating the call, giving the illusion that the call was answered.</p> <p>This is by design on the server side and is a known limitation.</p> <p>As a result, the answered event is not reliable for detecting when an outbound call is truly answered.</p>"},{"location":"events/answered/#inbound-calls","title":"Inbound calls","text":"<p>When your application code explicitly accepts the call (e.g., via <code>callSession.accept()</code>), the call is considered answered. In this case, triggering the answered event may be redundant since your code already initiated the answer action.</p>"},{"location":"events/answered/#sample","title":"Sample","text":"<pre><code>callSession.on(\"answered\", () =&gt; {\n  console.log(\"Call has been marked as answered.\");\n});\n</code></pre>"},{"location":"events/disposed/","title":"callSession.on('disposed', callback)","text":"<p>This event is triggered when the web phone instance is properly disposed of. This event does not fire when an instance expires. This event is useful if garbage collection is required when web phone are disposed of.</p>"},{"location":"events/disposed/#sample","title":"Sample","text":"<pre><code>callSession.on(\"disposed\", () =&gt; {\n  // do something with the inbound call\n});\n</code></pre>"},{"location":"events/inboundCall/","title":"webPhone.on('inboundCall', callback)","text":"<p>When the <code>inboundCall</code> event is triggered, you will receive as input an inbound call session. You may invoke any number of call session methods as well as a few others listed below.</p>"},{"location":"events/inboundCall/#sample","title":"Sample","text":"<pre><code>webPhone.on(\"inboundCall\", (inboundCall: InboundCallSession) =&gt; {\n  // do something with the inbound call\n});\n</code></pre>"},{"location":"events/inboundCall/#properties","title":"Properties","text":"Property Description <code>sipMessage</code> The message that triggered the event. You do not typically need to access this property directly. <code>localPeer</code> The user's device and connection. <code>remotePeer</code> The remote user's device and connection. <code>direction</code> Always equal to \"inbound.\" <code>state</code> The current state of the call. Either: init, ringing, answered, or disposed"},{"location":"events/inboundCall/#methods","title":"Methods","text":"Method Description <code>callId()</code> The current call ID. <code>sessionId()</code> The telephony session ID. <code>partyId()</code> The ID of the remote party. <code>remoteNumber()</code> The remote number connected to. <code>localNumber()</code> The local number. <code>isConference()</code> Boolean. <code>true</code> if the current call is a conference call."},{"location":"events/inboundMessage/","title":"callSession.on(<code>inboundMessage</code>, callback)","text":"<p>Registers a callback function to be invoked when a new inbound SIP message is received over the WebSocket connection.</p> <p>The inboundMessage event is emitted whenever the SIP client receives an inbound SIP message from the server. This includes various SIP methods such as INVITE, BYE, CANCEL, INFO, NOTIFY, and MESSAGE.</p> <p>This event provides access to the raw SIP message, allowing developers to handle custom SIP interactions or monitor SIP traffic for debugging and analytics purposes.</p>"},{"location":"events/inboundMessage/#callback-parameters","title":"Callback Parameters","text":"<p>The callback function receives a single parameter:</p> Parameter Type Description <code>message</code> <code>InboundMessage</code> An object representing the inbound SIP message, containing properties such as subject, headers, and body."},{"location":"events/inboundMessage/#usage-example","title":"Usage Example","text":"<pre><code>sipClient.on(\"inboundMessage\", (message) =&gt; {\n  console.log(\"Received SIP message:\", message.subject);\n  // Custom handling based on message type\n  if (message.subject.startsWith(\"MESSAGE sip:\")) {\n    // Handle SIP MESSAGE\n  }\n});\n</code></pre>"},{"location":"events/inboundMessage/#notes","title":"Notes","text":"<ul> <li> <p>Automatic 200 OK Responses: For certain SIP methods (MESSAGE, BYE, CANCEL,   INFO, and NOTIFY), the SIP client automatically sends a 200 OK response upon   receiving the message. This behavior ensures compliance with SIP protocol   expectations and reduces the need for manual acknowledgment.</p> </li> <li> <p>Message Filtering: The SIP client includes logic to filter out messages   not intended for the current instance, based on the <code>Cln</code> (Client ID) field in   the message body. If the <code>Cln</code> does not match the client's authorization ID,   the message is ignored.</p> </li> <li> <p>Debugging: If the SIP client is initialized with   debugging enabled (debug:   true), incoming messages are logged to the console, providing visibility into   SIP traffic for troubleshooting purposes.</p> </li> </ul>"},{"location":"events/outboundCall/","title":"webPhone.on('outboundCall', callback)","text":"<p>When the <code>outboundCall</code> event is triggered, you will receive as input an outbound call session. You may invoke any number of call session methods as well as a few others listed below.</p> <p>Truth be told, there is very little reason to subscribe to this event, as when a call is made, the outbound call session is returned from that method.</p>"},{"location":"events/outboundCall/#sample","title":"Sample","text":"<p>Explicit event subscription</p> <pre><code>webPhone.on(\"outboundCall\", (outboundCall: OutboundCallSession) =&gt; {\n  // do something with the inbound call\n});\n</code></pre> <p>When placing a call</p> <pre><code>const callSession = await webPhone.call(callee, callerId);\n</code></pre>"},{"location":"events/outboundCall/#properties","title":"Properties","text":"Property Description <code>sipMessage</code> The message that triggered the event. You do not typically need to access this property directly. <code>localPeer</code> The user's device and connection. <code>remotePeer</code> The remote user's device and connection. <code>direction</code> Always equal to \"outbound.\" <code>state</code> The current state of the call. Either: init, ringing, answered, or disposed"},{"location":"events/outboundCall/#methods","title":"Methods","text":"Method Description <code>callId()</code> The current call ID. <code>sessionId()</code> The telephony session ID. <code>partyId()</code> The ID of the remote party. <code>remoteNumber()</code> The remote number connected to. <code>localNumber()</code> The local number. <code>isConference()</code> Boolean. <code>true</code> if the current call is a conference call."},{"location":"events/outboundMessage/","title":"callSession.on(<code>outboundMessage</code>, callback)","text":"<p>Registers a callback function that will be invoked whenever a SIP message is sent from the client to the server.</p> <p>The outboundMessage event allows developers to observe all outbound SIP traffic generated by the SDK. This includes SIP methods like INVITE, ACK, BYE, CANCEL, INFO, MESSAGE, and others sent during the lifecycle of a SIP session.</p> <p>This event is primarily useful for debugging, logging, or implementing custom behavior based on outbound signaling.</p>"},{"location":"events/outboundMessage/#callback-parameters","title":"Callback Parameters","text":"Parameter Description <code>message</code> An object representing the outbound SIP message. <code>message.method</code> The SIP method used (e.g., 'INVITE', 'BYE') <code>message.uri</code> The target URI of the message <code>message.headers</code> SIP headers <code>message.body</code> Optional SIP message body (e.g., SDP)"},{"location":"events/outboundMessage/#usage-example","title":"Usage Example","text":"<pre><code>sipClient.on(\"outboundMessage\", (message) =&gt; {\n  console.log(\"Outbound SIP message:\", message.method, message.uri);\n  // Optionally inspect headers or modify logging\n});\n</code></pre>"},{"location":"events/outboundMessage/#notes","title":"Notes","text":"<ul> <li> <p>This event provides visibility into low-level SIP operations but does not   allow modification of the message before it is sent.</p> </li> <li> <p>When the SDK is initialized with   debugging enabled,   outbound messages may also be logged to the console automatically.</p> </li> </ul>"},{"location":"events/ringing/","title":"callSession.on('ringing', callback)","text":"<p>This event is triggered when a call is connected and it is ringing. It is an event that has very little utility, because when you make an outbound call, or by the time you receive an inbound call event, by the time the <code>callSession</code> object is returned, the phone is already ringing.</p> <p>Therefore, these two code samples are functionally equivalent to the <code>ringing</code> event:</p> Placing a callReceiving a call <pre><code>const callSession = await webPhone.call(...)\n</code></pre> <pre><code>webPhone.on('inboundCall', callSession =&gt; {...})\n</code></pre>"},{"location":"events/ringing/#sample","title":"Sample","text":"<pre><code>callSession.on('ringing', callSession =&gt; {...})\n</code></pre>"},{"location":"get-started/","title":"Get started with RingCentral's WebPhone SDK","text":"<p>The WebPhone SDK empowers developers to build their own custom browser-based phone and CTI. Getting started in quick and easy for those who have a RingCentral developer account. Let's take you through the process.</p>"},{"location":"get-started/#obtain-a-client-id-and-secret","title":"Obtain a client ID and secret","text":"<p>If you have not already, signup for a RingCentral Developer account. Then:</p> <ol> <li> <p>Login to the    Developer Console</p> </li> <li> <p>Register your application    with following settings:</p> </li> <li>Select \"JWT auth flow\" under Auth</li> <li> <p>Select the following application scopes:</p> <ul> <li>VoIP Calling</li> <li>WebSocket Subscriptions</li> </ul> </li> <li> <p>Generate a JWT credential</p> </li> </ol> <p>Then, make note of your Client ID and Client Secret, you will need them later.</p>"},{"location":"get-started/#install-the-sdk","title":"Install the SDK","text":"<p>Download and install the SDK from npmjs:</p> <pre><code>yarn add ringcentral-web-phone\n</code></pre>"},{"location":"get-started/#alternative-methods","title":"Alternative methods","text":"<p>You can use this library directly without a bundling tool. Just download a release, unzip it, and load it via a <code>&lt;script&gt;</code> tag.</p> LocallyCDN <pre><code>&lt;script src=\"/path/to/ringcentral-web-phone/dist/esm/index.umd.js\"&gt;&lt;/script&gt;\n</code></pre> <pre><code>&lt;script\n  src=\"https://cdn.jsdelivr.net/npm/ringcentral-web-phone@2.1.5/dist/esm/index.umd.js\"\n&lt;/script&gt;\n</code></pre>"},{"location":"get-started/#register-your-web-phone","title":"Register your web phone","text":"<p>!!! tip \"Are you a new RingCentral developer?\" For the purposes of this getting started exercise, we assume you have basic knowledge of the RingCentral Platform and how to calls its APIs. If you are new to RingCentral, we recommend going through the getting started experience found in our Developer Guide.</p> <p>To begin, you need to register your \"device\" associated with the phone you are about to build. Registration is done by calling the SIP registration API. You will need the <code>sipInfo</code> object returned by this API.</p>"},{"location":"get-started/#sample-code","title":"Sample code","text":"<pre><code>import RingCentral from \"@rc-ex/core\";\n\nconst rc = new RingCentral({\n  server: process.env.RINGCENTRAL_SERVER_URL,\n  clientId: process.env.RINGCENTRAL_CLIENT_ID,\n  clientSecret: process.env.RINGCENTRAL_CLIENT_SECRET,\n});\n\nconst main = async () =&gt; {\n  await rc.authorize({\n    jwt: process.env.RINGCENTRAL_JWT_TOKEN!,\n  });\n  const r = await rc\n    .restapi()\n    .clientInfo()\n    .sipProvision()\n    .post({\n      sipInfo: [{ transport: \"WSS\" }],\n    });\n  const sipInfo = r.sipInfo![0];\n  console.log(sipInfo); // this is what we need\n\n  const deviceId = r.device!.id; // Web Phone SDK doesn't need `deviceId`, just for your information.\n  await rc.revoke(); // Web Phone SDK doesn't need a long-living Restful API access token, you MAY logout\n};\nmain();\n</code></pre> <p>!!! tip \"Save <code>sipInfo</code> for later use\" Please note that, you may save and re-use <code>sipInfo</code> for a long time. You don't need to invoke <code>Device SIP Registration</code> every time you start the web phone.</p> <p>!!! tip \"Save <code>deviceId</code> for use in the REST API\" In the sample code above, you can see how to access the <code>deviceId</code>. The Web Phone SDK doesn't need the <code>deviceId</code>, but it is useful when calling certain REST APIs, like the Call Control API.</p>"},{"location":"get-started/#initialize-your-webphone","title":"Initialize your WebPhone","text":"<p>With your <code>sipInfo</code> in hand, you can initialize an instance of your WebPhone.</p> <pre><code>import WebPhone from \"ringcentral-web-phone\";\n\nconst webPhone = new WebPhone({ sipInfo });\nawait webPhone.start();\n</code></pre>"},{"location":"get-started/#next-steps","title":"Next steps...","text":"<p>Once your WebPhone is initialized, you can then begin building your client. You can:</p> <ul> <li>Subscribe to events</li> <li>Place or receive a phone call</li> </ul>"},{"location":"get-started/instances/","title":"Instantiating a WebPhone","text":"<p>In our getting started guide you learned how to register your WebPhone device and obtain a <code>sipInfo</code> object. You will need the <code>sipInfo</code> object below.</p>"},{"location":"get-started/instances/#creating-an-instance","title":"Creating an instance","text":"<p>Use your saved <code>sipInfo</code> object to instantiate a WebPhone.</p> <pre><code>import WebPhone from \"ringcentral-web-phone\";\n\nconst webPhone = new WebPhone({ sipInfo });\nawait webPhone.start();\n</code></pre>"},{"location":"get-started/instances/#working-with-multiple-webphone-instances","title":"Working with multiple WebPhone instances","text":"<p>When you instantiate a WebPhone an instance ID will be assigned to your instance. The instance ID defaults to the value of <code>sipInfo.authorizationId</code>. If you plan on instantiating multiple instances of your WebPhone, each instance will need a unique ID, which can be provided directly:</p> <pre><code>const webPhone = new WebPhone({ sipInfo, instanceId });\n</code></pre> <p>When creating instance IDs, please be aware of the following requirements (see RFC5626):</p> <ol> <li>Each instance ID MUST be unique for each device</li> <li>Each instance ID MUST be persistent across power cycles of the device</li> <li>Each instance ID MUST NOT change as the device moves from one network to    another</li> </ol> <p>If you start two web phone instances with the same <code>instanceId</code>, only the second instance will be able to receive calls, as the RingCentral SIP server will not route calls to the first instance. Both instances however will be able to place calls. However, if you use unique instance IDs, then both instances will receive SIP messages, including incoming calls.</p> <p>!!! warning \"A maximum of five instances are allowed\" The maximum unique live instances allowed for an extension is 5. If you try to register more, the SIP server will reply with \"SIP/2.0 603 Too Many Contacts\".</p> <pre><code>If you keep refreshing a browser page and each refresh generates a unique `instanceId`, then registration will fail upon creating the 6th web phone instance.\n</code></pre> <p>!!! tip \"Shared workers\" If you anticipate working with multiple WebPhone instance, a practice common when opening multiple tabs in the same browser, then we recommend you learn more about shared workers which can help you create a more scalable solution that is not constrained by the five instance limit.</p>"},{"location":"get-started/instances/#instance-expiry","title":"Instance expiry","text":"<p>It takes around one minute for the SIP server to mark an instance as expired (if client doesn't refresh it any more). So after you receive the \"SIP/2.0 603 Too Many Contacts\" error, you must wait one minute before trying again.</p>"},{"location":"get-started/instances/#disposing-of-an-instance","title":"Disposing of an instance","text":"<p>Alternatively, you can invoke <code>dispose()</code> to dispose of a web phone instance before you close/refresh a browser page. That way, the web phone instance registration is forcibly removed from the SIP server immediately. This will avoid you having to wait one minute for the instance to expire naturally.</p> <pre><code>await webPhone.dispose();\n</code></pre>"},{"location":"get-started/instances/#turning-on-debug-mode","title":"Turning on debug mode","text":"<p>In debug mode, the SDK will print all SIP messages to the console. It is useful for debugging.</p> <pre><code>const webPhone = new WebPhone({ sipInfo, debug: true });\n</code></pre>"},{"location":"get-started/sessions/","title":"Call sessions","text":"<p>Once you have instantiated a WebPhone instance, you need to establish a session in order to perform many of the actions you would associate with phone calls. Sessions are created in of two quite logical ways:</p> <ol> <li>You can place a call by dialing a phone number.</li> <li>You can receive a call.</li> </ol>"},{"location":"get-started/sessions/#outbound-call-sessions","title":"Outbound call sessions","text":"<p>To initiate a phone call, you use the <code>call()</code> method.</p> <pre><code>const callSession = await webPhone.call(callee, callerId);\n</code></pre>"},{"location":"get-started/sessions/#inbound-call-sessions","title":"Inbound call sessions","text":"<p>To obtain a session associated with an inbound call, you will need to subscribe to the <code>inboundCall</code> event:</p> <pre><code>webPhone.on(\"inboundCall\", (inboundCallSession: InboundCallSession) =&gt; {\n  // do something with the inbound call session\n});\n</code></pre>"},{"location":"get-started/sessions/#next-steps","title":"Next steps","text":"<p>With a call session in hand, you can call any number of methods associated with call sessions found in our reference.</p>"},{"location":"get-started/shared-workers/","title":"Managing multiple WebPhone instances using SharedWorker","text":"<p>Most browser-based applications allow users to open multiple tabs. In each tab you may have a distinct WebPhone instance. However, there is a limit of how many instances you can run per each extension. So what if the user opens too many tabs? This will lead to unpredictable results.</p> <p>To allow a user to open an unlimitted number of tabs without ever hitting a limit, one cab have one tab run a primary phone while all other tabs run secondary or dummy phones. Dummy phones don't register themselves to the RingCentral Server. Instead, only the primary phone does, and then it syncs its state to all the dummy phones. When user performs an action on a dummy phone, the dummy phone forwards the action to the primary phone. The primary phone then performs the action and syncs the state back to all the other dummy phones.</p> <p>To achieve this, you will need to use a SharedWorker.</p>"},{"location":"get-started/shared-workers/#how-sharedworkers-work","title":"How SharedWorkers work","text":"<p>This is how a shared worker functons:</p> <ol> <li>The primary phone sends its state to SharedWorker.</li> <li>SharedWorker transmits that state to all available dummy phones.</li> <li>The dummy phones update their state and UI accordingly.</li> </ol> <p>Conversely, when the user performs an action on a dummy phone:</p> <ol> <li>The dummy phone forwards the action to SharedWorker.</li> <li>SharedWorker forwards the action to the primary phone.</li> <li>The primary phone performs the action and sends its new state to    SharedWorker.</li> </ol> <p>And the process repeats itself.</p> <p>When the primary phone quits (the browser tab closes, the user navigates away to another page, etc), then a dummy phone is automatically promoted to become the new primary phone. This way, there is always one and only one primary phone.</p>"},{"location":"get-started/shared-workers/#sample-code-and-technical-details","title":"Sample code and technical details","text":"<p>A primary phone is initiated like this:</p> <pre><code>import SipClient from \"ringcentral-web-phone/sip-client\";\n\nnew WebPhone({ sipInfo, sipClient: new SipClient({ sipInfo }) });\n</code></pre> <p>Or even simpler (since <code>sipClient</code> is optional with default value <code>new SipClient({ sipInfo })</code>):</p> <pre><code>new WebPhone({ sipInfo });\n</code></pre> <p>A dummy phone is initiated like this:</p> <pre><code>import { DummySipClient } from \"ringcentral-web-phone/sip-client\";\n\nnew WebPhone({ sipInfo, sipClient: new DummySipClient() });\n</code></pre> <p>You may need to re-initiate a dummy phone to a real phone when the previous primary phone quits.</p> <p>A <code>DummySipClient</code> doesn't register itself with the RingCentral Server, nor does it send any SIP messages to the RingCentral Server. It is effectively inert.</p> <p>Then, you will need to implement a SharedWorker to:</p> <ul> <li>sync the state from the real phone to all dummy phones.</li> <li>forward actions from dummy phones to the real phone.</li> </ul>"},{"location":"get-started/shared-workers/#sample-sharedworker","title":"Sample SharedWorker","text":"<pre><code>const dummyPorts = new Set&lt;MessagePort&gt;();\nlet realPort: MessagePort | undefined;\n\nlet syncCache: any;\nself.onconnect = (e) =&gt; {\n  const port = e.ports[0];\n  if (realPort) {\n    dummyPorts.add(port);\n    port.postMessage({ type: \"role\", role: \"dummy\" });\n  } else {\n    realPort = port;\n    port.postMessage({ type: \"role\", role: \"real\" });\n  }\n  port.onmessage = (e) =&gt; {\n    // a new dummy is ready to receive state\n    if (e.data.type === \"ready\") {\n      if (port !== realPort &amp;&amp; syncCache) {\n        port.postMessage(syncCache);\n      }\n    } // a tab closed\n    else if (e.data.type === \"close\") {\n      if (port === realPort) {\n        realPort = undefined;\n\n        // if real closes, all call sessions are over.\n        dummyPorts.forEach((dummyPort) =&gt;\n          dummyPort.postMessage({ type: \"sync\", jsonStr: \"[]\" })\n        );\n\n        // prompt a dummy to be a real\n        if (dummyPorts.size &gt; 0) {\n          realPort = Array.from(dummyPorts)[0];\n          dummyPorts.delete(realPort);\n          realPort.postMessage({ type: \"role\", role: \"real\" });\n        }\n      } else {\n        dummyPorts.delete(port);\n      }\n    } else if (e.data.type === \"action\") {\n      // forward action to real\n      if (realPort) {\n        realPort.postMessage(e.data);\n      }\n    } else if (e.data.type === \"sync\") {\n      // sync state to all dummies\n      syncCache = e.data;\n      dummyPorts.forEach((dummyPort) =&gt; dummyPort.postMessage(e.data));\n    }\n  };\n};\n</code></pre>"},{"location":"get-started/shared-workers/#sample-client-code","title":"Sample client code","text":"<pre><code>worker.port.onmessage = (e) =&gt; {\n  if (e.data.type === \"role\") {\n    // role assigned/updated\n    store.role = e.data.role;\n    // you may need to (re-)initiate the web phone\n  } else if (store.role === \"real\" &amp;&amp; e.data.type === \"action\") {\n    // real gets action from dummy\n  } else if (store.role === \"dummy\" &amp;&amp; e.data.type === \"sync\") {\n    // dummy gets state from real\n  }\n};\n</code></pre>"},{"location":"get-started/shared-workers/#a-sample-action-processing-code","title":"A sample action processing code","text":"<pre><code>public async transfer(callId: string, transferToNumber: string) {\n  if (this.role === 'dummy') {\n    worker.port.postMessage({ type: 'action', name: 'transfer', args: { callId, transferToNumber } });\n    return;\n  }\n  await this.webPhone.callSessions.find((cs) =&gt; cs.callId === callId)!.transfer(transferToNumber);\n}\n</code></pre>"},{"location":"get-started/shared-workers/#full-working-example","title":"Full working example","text":"<p>A fully working example is available so that you can see it working with multiple browser tabs.</p>"},{"location":"get-started/testing/","title":"Testing your phone","text":""},{"location":"get-started/testing/#how-to-test","title":"How to test","text":"<p>rename <code>.env.sample</code> to <code>.env</code> and fill in the correct values. You will need two RingCentral extensions to test the SDK, one as the caller and the other as the callee. You will need the <code>sipInfo</code> json string of the two extensions. Invoke this API to get <code>sipInfo</code>.</p> <p>You may need to <code>yarn playwright install chromium</code> if playwright cannot find chromium.</p> <p>You will need one more number to test call forwarding/transferring.</p> <p>To run all tests:</p> <pre><code>yarn test\n</code></pre> <p>To run a test file:</p> <pre><code>yarn test test/inbound/forward.spec.ts\n</code></pre>"},{"location":"get-started/testing/#two-kinds-of-special-messages","title":"Two kinds of special messages","text":"<p>Before an inbound call is answered, client may send special messages with XML body to confirmReceive/toVoicemail/decline/forward/reply the call.</p> <p>In an ongoing call (either inbound or outbound), client may send special messages with JSON body to startCallRecord/stopCallRecord/flip/park the call.</p>"},{"location":"get-started/testing/#webphone-unregister","title":"webPhone unregister","text":"<p>Register the SIP client with expires time 0. It means that the SIP client will be unregistered immediately after the registration. After this method call, no inbound call will be received. If you try to make an outbound call, you will get a <code>SIP/2.0 403 Forbidden</code> response.</p>"},{"location":"get-started/testing/#multiple-instances","title":"multiple instances","text":"<p>Every time you get a new <code>sipInfo</code>, you will get a new <code>authorizationId</code>. So different instances will have different <code>authorizationId</code>, unless you share the same <code>sipInfo</code>.</p> <p>If there are 3 instances, after an inbound call is answered, each instance will receive 3 messages with Cmd=\"7\" with different Cln=\"xxx\". \"xxx\" here is authorizationId.</p>"},{"location":"recipes/auto-answer/","title":"Auto-answer a call","text":"<p>The Auto-Answer feature enables your application to automatically accept incoming SIP calls based on specific SIP headers or through custom logic. This is particularly useful for automated systems, call centers, or integrations requiring immediate call handling.</p> <p>!!! note \"Use this approach with caution, as it will accept all incoming calls automatically, which may not be suitable for all applications.\"</p>"},{"location":"recipes/auto-answer/#enabling-auto-answer","title":"Enabling Auto-Answer","text":"<p>By default, Auto-Answer is disabled. You can enable it during the instantiation of the WebPhone instance or afterward:</p> <p>Enable during instantiation:</p> <pre><code>const webPhone = new WebPhone({\n  sipInfo,\n  autoAnswer: true,\n});\n</code></pre> <p>Enable after instantiation:</p> <pre><code>webPhone.autoAnswer = true;\n</code></pre>"},{"location":"recipes/auto-answer/#how-it-works","title":"How It Works","text":"<p>When Auto-Answer is enabled, the SDK inspects incoming SIP INVITE messages for specific headers:</p> <ul> <li>Alert-Info Header: If this header is present with the value Auto Answer,   the call will be auto-answered.</li> <li>Call-Info Header: If this header contains Answer-After=, the call   will be auto-answered after the specified delay in seconds."},{"location":"recipes/auto-answer/#example-sip-headers","title":"Example SIP Headers:","text":"<pre><code>Alert-Info: Auto Answer\nCall-Info: &lt;224981555_132089748@10.13.116.50&gt;;purpose=info;Answer-After=0\n</code></pre> <p>In this example, the call will be auto-answered immediately upon receipt.</p>"},{"location":"recipes/auto-answer/#use-cases","title":"Use Cases","text":"<p>Auto-Answer is essential for certain call control APIs, such as the Answer Call Party API. When this API is invoked, the current call session is canceled, and a new inbound call with auto-answer headers is sent to the target device. If Auto-Answer is enabled, the call is automatically accepted.</p>"},{"location":"recipes/auto-answer/#auto-answer-all-calls","title":"Auto-Answer All Calls","text":"<p>If you want to auto-answer all incoming calls, regardless of SIP headers, you can implement custom logic:</p> <pre><code>webPhone.on(\"inboundCall\", async (callSession) =&gt; {\n  await callSession.answer();\n});\n</code></pre>"},{"location":"recipes/barging-in/","title":"Taking action on a live call as a third-party","text":"<p>WebPhone SDK allows you to monitor, whisper, barge in on, coach, and take over a phone call. These features are available to all phone clients, not just clients powered by this SDK.</p> <p>Please refer to our support article on the procedure that involves dialing certain numbers, e.g. <code>*80</code>.</p>"},{"location":"recipes/barging-in/#barge-in","title":"Barge-in","text":"<p>To barge in on a call (join an existing call) which is being handled by extension 102, do the following:</p> <pre><code>const callSession = await webPhone.call(\"*82\");\n// optionally wait for 1 - 3 seconds here\nawait callSession.sendDtmf(\"102#\");\n</code></pre>"},{"location":"recipes/barging-in/#take-over","title":"Take-over","text":"<p>Taking over a call requires a little more finesse, as it process a little bit differently. When you send a request for taking over an existing call, you will receive an extra inbound call from '*83'. You need to answer that inbound call for the \"take over\" to complete. You also need to keep both calls alive, otherwise the customer will be disconnected.</p> <p>For example, a customer is talking to extension 102, and you want to take over the call:</p> <pre><code>const callSession1 = await webPhone.call(\"*83\");\n// optionally wait for 1 - 3 seconds here\nawait callSession1.sendDtmf(\"102#\");\nwebPhone.on(\"inboundCall\", async (callSession2: InboundCallSession) =&gt; {\n  if (callSession2.remoteNumber === \"*83\") {\n    await callSession2.answer(); // this could be done manually by user instead of automatically here.\n  }\n});\n</code></pre> <p>You will need to keep both <code>callSession1</code> and <code>callSession2</code> alive in order to keep the conversation alive with the customer. If you hang up either one, the customer will be disconnected.</p>"},{"location":"recipes/call-control/","title":"Using the Call Control API","text":""},{"location":"recipes/call-control/#call-control-apis","title":"Call control APIs","text":"<p>Ref: https://developers.ringcentral.com/api-reference/Call-Control/createCallOutCallSession</p> <p>Call control APIs are out of scope of this SDK, since they are all Restful APIs. I will provide some brief information here.</p> <p>I believe most users/developers of this SDK don't need to use call control API. Since the SDK can control calls already, like answer/hang up/transfer/hold/park...etc. There is really no good reason to not use the SDK provided call control, but to use Restful API call control.</p> <p>With above being said, it is easy to use Restful call control API together with this SDK.</p>"},{"location":"recipes/call-control/#answer-call-party","title":"Answer call party","text":"<p>answer call party API</p> <pre><code>import RingCentral from '@rc-ex/core';\n\npublic async callControlAnswer(callSession: CallSession) {\n  const rc = new RingCentral({ server });\n  rc.token = { access_token }; // re-use existing access token. You may generate new token instead\n  await rc\n    .restapi()\n    .account()\n    .telephony()\n    .sessions(callSession.sessionId) // sessionId and partyId are accessible directly\n    .parties(callSession.partyId)\n    .answer()\n    .post({\n      deviceId, // where to get deviceId? refer to \"Pre-requisites\" section of this README file\n    });\n}\n</code></pre> <p>After you make this API call, the current call session will be cancelled and new incoming call with Auto Answer SIP headers will be received. If you enabled auto answer feature of this SDK, the call will be auto answered.</p> <p>The example above is just to demonstrate how to use call control API with this SDK. It's unnecessarily complicated compared to:</p> <pre><code>await callSession.answer();\n</code></pre>"},{"location":"recipes/call-control/#make-call-out","title":"Make Call out","text":"<pre><code>const rc = new RingCentral({ server: this.server });\nrc.token = { access_token: this.rcToken }; // re-use existing token\nawait rc\n  .restapi()\n  .account()\n  .telephony()\n  .callOut().post({\n    from: { deviceId }, // where to get deviceId? refer to \"Pre-requisites\" section of this README file\n    to: { phoneNumber: toNumber },\n  });\n</code></pre> <p>After invoking this API, the current webPhone instance will receive an incoming call with auto answer SIP headers. If you enabled auto answer feature of this SDK, the call will be auto answered. The <code>toNumber</code> will also receive an incoming call. If he/she answers it too, you two can talk to each other.</p> <p>To me, it is similar to RingOut, differences are:</p> <ul> <li>CallOut let you specify deviceID instead of phone number. So, it's more   specific about which device is going to get the phone call.</li> <li>For callout, inbound call to the device will have auto answer headers. It   could be auto answered if the device supports it.</li> </ul> <p>Again, you are not required to use the RESTful API to do a call out. This is way simpler:</p> <pre><code>const callSession = await webPhone.call(callee);\n</code></pre>"},{"location":"recipes/conference-calls/","title":"Conference calls","text":""},{"location":"recipes/conference-calls/#conference","title":"Conference","text":"<p>Conference is out of the scope of this SDK. Because conferences are mainly done with Restful API. With above being said, I will provide some code snippets for your reference.</p>"},{"location":"recipes/conference-calls/#create-a-conference","title":"Create a conference","text":"<p>To create a conference: https://developers.ringcentral.com/api-reference/Call-Control/createConferenceCallSession If you are using SDK <code>@rc-ex/core</code>, you can do it like this:</p> <pre><code>const r = await rc.restapi().account().telephony().conference().post();\n</code></pre> <p>In the response of the above API call, you will get a <code>r.session!.voiceCallToken!</code>. As the host, you will need to dial in:</p> <pre><code>const confSession = await webPhone.call(r.session!.voiceCallToken!);\n</code></pre>"},{"location":"recipes/conference-calls/#invite-a-number-to-the-conference","title":"Invite a number to the conference","text":"<p>Make a call to the number you want to invite to the conference:</p> <pre><code>const callSession = await this.webPhone.call(targetNumber);\n</code></pre> <p>Then you can bring in the call to the conference.</p> <pre><code>await rc.restapi().account().telephony().sessions(confSession.sessionId)\n  .parties().bringIn().post({\n    sessionId: callSession.sessionId,\n    partyId: callSession.partyId,\n  });\n</code></pre>"},{"location":"recipes/conference-calls/#merge-an-existing-ongoing-call-to-the-conference","title":"Merge an existing ongoing call to the conference","text":"<p>Let's say an existing call session is <code>callSession</code>.</p> <pre><code>await rc.restapi().account().telephony().sessions(confSession.sessionId)\n  .parties().bringIn().post({\n    sessionId: callSession.sessionId,\n    partyId: callSession.partyId,\n  });\n</code></pre> <p>You can see that it doesn't matter how the call is created, it could be either an outbound call or an inbound call. You could create it on-the-fly or you can find an existing call session.</p>"},{"location":"recipes/conference-calls/#a-live-sample","title":"A live sample","text":"<p>https://github.com/tylerlong/rc-web-phone-demo-2 provides conference features. You may create conference, invite a number to the conference, merge an existing call to the conference, etc.</p>"},{"location":"recipes/private-parking/","title":"Privately parking a call","text":"<p>RingCentral supports park location feature. You may create a park location with a name, and specify who can park/retrieve calls to/from this location.</p> <p>To park to a predefined location, you need to get the location's ID. You will need to login https://service.ringcentral.com and go to \"Phone System &gt; Groups &gt; Park Locations\". Click the park location and you will see its ID in browser URL. Save it as <code>parkLocationId</code>.</p> <p>To park a call to a park location, just do this:</p> <pre><code>await callSession.transfer(`prk${parkLocationId}`);\n</code></pre> <p>Please note that, the call must be answered before it can be private parked. You cannot park a still ringing call. As I tested, parking an unanswered call will receive <code>SIP/2.0 202 Accepted</code> from server but the call is not parked at all.</p>"},{"location":"recipes/private-parking/#retrieve-private-parked-calls","title":"Retrieve private parked calls","text":"<p>This part requires you to invoke RESTful API and setup subscriptions. It's out of the scope of this SDK. Here I just provide the information for your reference:</p> <p>You will need to subscribe to the following event filter:</p> <p><code>/restapi/v1.0/account/~/extension/{parkLocationId}/presence?detailedTelephonyState=true&amp;sipData=true</code></p> <p>When someone private parks a call, they will be able to get a notification, similar to the one below.</p> <pre><code>\"body\": {\n \"extensionId\": &lt;parkLocationId&gt;,\n \"telephonyStatus\": \"ParkedCall\",\n \"activeCalls\": [\n   {\n     \"sipData\": {\n       \"toTag\": \"gK061ccd05\",\n       \"fromTag\": \"10.14.22.230-5070-fd226b1e-f8bd-43aa\",\n     },\n     \"telephonySessionId\": \"s-a0e16e61c511cz1935660a889zd0e85b0000\"\n   }\n ],\n ...\n</code></pre> <p>You need to write code like this to retrieve it:</p> <pre><code>await webPhone.call(`prk${parkLocationId}`, undefined, {\n  headers: {\n    Replaces:\n      `${telephonySessionId};to-tag=${fromTag};from-tag=${toTag};early-only`,\n  },\n});\n</code></pre> <p>Please pay attention to <code>to-tag=${fromTag};from-tag=${toTag}</code>, it is NOT <code>to-tag=${toTag};from-tag=${fromTag}</code>!</p>"},{"location":"recipes/private-parking/#see-also","title":"See also","text":"<ul> <li>Demo application</li> </ul>"},{"location":"recipes/recovery/","title":"Recovering from an outage","text":""},{"location":"recipes/recovery/#recover-from-network-outageissuechange","title":"Recover from network outage/issue/change","text":"<p>Please note that, this SDK doesn't detect network outage/issue/change. Our philosophy is to avoid adding any magic logic to the SDK.</p> <p>For a working example to handle network outage/issue/change, please refer to https://github.com/tylerlong/rc-web-phone-demo-2/blob/main/src/store/after-login.ts. Scroll to the bottom part where it handles network outage/issue/change.</p>"},{"location":"recipes/recovery/#network-outage","title":"network outage","text":"<p>If you believe your app just recovered from network outage and the underlying WebSocket connection is broken, you may call <code>webPhone.start()</code>. It will create a brand new websocket connection to the SIP server and re-register the SIP client.</p> <p>A sample implemetation could be as simple as this:</p> <pre><code>// browser issues network online event.\nwindow.addEventListener(\"online\", () =&gt; webPhone.start());\n</code></pre> <p>Please note that, in this case, existing calls will recover automatically by WebRTC unless the network changed(like from one WiFi to another, or from WiFi to cellular). For network change, please read sections below.</p>"},{"location":"recipes/recovery/#network-issue","title":"network issue","text":"<p>What if network is not offline, but underlying WebSocket connection is broken? This is very unlikely to happen, but if it happens, the following code will try to bring your web phone back to work:</p> <pre><code>import waitFor from \"wait-for-async\";\n\nconst closeListener = async (e) =&gt; {\n  webPhone.sipClient.wsc.removeEventListener(\"close\", closeListener);\n  if (webPhone.disposed) {\n    // webPhone.dispose() has been called, no need to reconnect\n    return;\n  }\n  console.log(\"WebSocket disconnected unexpectedly\", e);\n  let connected = false;\n  let delay = 2000; // initial delay\n  while (!connected) {\n    console.log(`Reconnect WebSocket in ${delay / 1000} seconds`);\n    await waitFor({ interval: delay });\n    try {\n      await webPhone.start();\n      connected = true;\n    } catch (e) {\n      console.log(\"Error connecting to WebSocket\", e);\n      delay *= 2; // exponential backoff\n      delay = Math.min(delay, 60000); // max delay 60s\n    }\n  }\n  // because webPhone.start() will create a new webPhone.sipClient.wsc\n  webPhone.sipClient.wsc.addEventListener(\"close\", closeListener);\n};\nwebPhone.sipClient.wsc.addEventListener(\"close\", closeListener);\n</code></pre> <p>By default the SDK will send a <code>register</code> message around every 60 seconds. If there is no response from server in 5 seconds(which indicates that the WebSocket connection is probably broken), the SDK will proactively close the WebSocket connection, which will trigger the logic above to invoke <code>webPhone.start()</code>.</p>"},{"location":"recipes/recovery/#network-change","title":"network change","text":"<p>Like switching from WiFi to mobile hot spot, or switching from one WiFi to another.</p> <p>In such cases, both the WebSocket connection and the WebRTC connections will break.</p> <p><code>webPhone.start()</code> will recover the WebSocket connection. But WebRTC connections are still broken.</p> <p>This is not an issue if there are no active call sessions ongoing. But if there are active call sessions when the network switches from one to another, the existing call sessions will become \"silent\".</p> <p>The solution is to send \"re-INVITE\" for each ongoing call session:</p> <pre><code>webPhone.callSessions.forEach((callSession) =&gt; {\n  if (callSession.state === \"answered\") {\n    callSession.reInvite();\n  }\n});\n</code></pre> <p>\"re-INVITE\" will re-establish the WebRTC connections based on latest network information.</p>"},{"location":"recipes/recovery/#sample-code-to-handle-all-cases-network-outageissuechange","title":"Sample code to handle all cases (network outage/issue/change)","text":"<pre><code>const recover = async () =&gt; {\n  await webPhone.start();\n  webPhone.callSessions.forEach((callSession) =&gt; {\n    if (callSession.state === \"answered\") {\n      // in case the network switches from one to another\n      callSession.reInvite();\n    }\n  });\n};\n\n// handle network outage\nwindow.addEventListener(\"online\", async () =&gt; {\n  await recover();\n});\n\n// handle network issues\nconst closeListener = async (e) =&gt; {\n  webPhone.sipClient.wsc.removeEventListener(\"close\", closeListener);\n  if (webPhone.disposed) {\n    // webPhone.dispose() has been called, no need to reconnect\n    return;\n  }\n  console.log(\"WebSocket disconnected unexpectedly\", e);\n  let connected = false;\n  let delay = 2000; // initial delay\n  while (!connected) {\n    console.log(`Reconnect WebSocket in ${delay / 1000} seconds`);\n    await waitFor({ interval: delay });\n    try {\n      await recover();\n      connected = true;\n    } catch (e) {\n      console.log(\"Error connecting to WebSocket\", e);\n      delay *= 2; // exponential backoff\n      delay = Math.min(delay, 60000); // max delay 60s\n    }\n  }\n  // because webPhone.start() will create a new webPhone.sipClient.wsc\n  webPhone.sipClient.wsc.addEventListener(\"close\", closeListener);\n};\nwebPhone.sipClient.wsc.addEventListener(\"close\", closeListener);\n</code></pre> <p>Latest tested code could be found here: https://github.com/tylerlong/rc-web-phone-demo-2/blob/main/src/store/after-login.ts Scroll to the bottom part where it handles network outage/issue/change.</p>"},{"location":"recipes/recovery/#switch-to-backup-outbound-proxy","title":"switch to backup outbound proxy","text":"<p>There are both <code>sipInfo.outboundProxy</code> and <code>sipInfo.outboundProxyBackup</code>. By default <code>sipInfo.outboundProxy</code> is used. In very rare cases, <code>sipInfo.outboundProxy</code> is broken and you will need to connect to <code>sipInfo.outboundProxyBackup</code> instead. First of all, this shouldn't happen at all. RingCentral will make sure that <code>sipInfo.outboundProxy</code> is always up and running. So <code>sipInfo.outboundProxyBackup</code> is just in case.</p> <p>The SDK doesn't automatically switch to backup outbound proxy because we don't want to add any magical logic to the code base. As we said you probably don't need to do this, but if you have to do, we have you covered.</p> <p>We allow you to use your own SipClient: <code>const webPhone = new WebPhone({sipClient: new MyOwnSipClient()})</code>. If you do so, you gain extreme flexibility. How to switch to backup outbound proxy is up to you.</p> <p>If you didn't specify your own <code>SipClient</code> implementation, DefaultSipClient will be used. And to switch to backup outbound proxy: <code>(webPhone.sipClient as DefaultSipClient).toggleBackupOutboundProxy(true)</code>. To switch back to the original outbound proxy: <code>(webPhone.sipClient as DefaultSipClient).toggleBackupOutboundProxy(false)</code>.</p> <p>You will need to invoke <code>webPhone.start()</code> to re-create the WebSocket connection, otherwise it is still the old outbound proxy.</p>"},{"location":"recipes/switch-to-this-device/","title":"Switch call to this device","text":""},{"location":"recipes/switch-to-this-device/#switch-call-to-this-device","title":"Switch call to this device","text":"<p>Let's say you are having a phone call on your mobile phone app. And you would like to switch the call to desktop app.</p> <p>The official RingCentral apps for mobile and desktop already supports it, please refer to this article.</p> <p>But how do we achieve the same with this SDK?</p> <p>First of all, you will need the <code>sipData</code> of the ongoing call. Especially, the <code>telephonySessionId</code>, the <code>fromTag</code> and the <code>toTag</code>.</p> <p>Once you have that, it is easy to switch the call to this device:</p> <pre><code>this.webPhone.call(\"whatever\", undefined, {\n  headers: {\n    Replaces:\n      `${telephonySessionId};to-tag=${toTag};from-tag=${fromTag};early-only`,\n  },\n});\n</code></pre> <p>The \"callee\" number we specified above is \"whatever\". Since we are not making a new outbound call, we just try to replace an existing call. The callee number could be fake.</p>"},{"location":"recipes/switch-to-this-device/#where-to-get-sipdata","title":"Where to get sipData?","text":"<p>Where to get the <code>telephonySessionId</code>, the <code>fromTag</code> and the <code>toTag</code>?</p> <p>If you are using some SDKs, like this SDK, or the softphone SDK, you will be able to get them via the headers of SIP messages.</p> <p>Or you could get them by setting up subscriptions. It's a topic out of the scope of this SDK. You may find more details here: https://github.com/tylerlong/rc-softphone-call-id-test</p>"},{"location":"reference/","title":"WebPhone SDK Reference","text":""},{"location":"reference/#webphone-methods","title":"WebPhone methods","text":"Method Description <code>call()</code> Initiate a phone call <code>dispose()</code> Properly disponse of a WebPhone instance"},{"location":"reference/#call-session-methods","title":"Call Session methods","text":"Method Description <code>answer()</code> Answer an incoming call <code>decline()</code> Decline an incoming call <code>flip()</code> <code>forward()</code> Forward an incoming call to another number <code>hangup()</code> Terminate the current call <code>hold()</code> Place the current call on hold <code>mute()</code> Mute the current call <code>park()</code> Park the current call <code>reInvite()</code> <code>reply()</code> <code>sendDtmf()</code> <code>startRecording()</code> Start a call recording <code>startReply()</code> <code>stopRecording()</code> Stop/pause a call recording <code>toVoicemail()</code> Send an incoming call to voicemail <code>transfer()</code> Transfer the current call to another number <code>unhold</code> Take the current call off of hold <code>unmute()</code> Unmute the current call <code>warmTransfer()</code> Perform a warm transfer of the current call"},{"location":"reference/answer/","title":"callSession.answer()","text":"<p>This is reserved for inbound call sessions only.</p> <p>Answers an incoming call so that you can talk to the caller.</p>"},{"location":"reference/answer/#sample","title":"Sample","text":"<pre><code>await callSession.answer();\n</code></pre>"},{"location":"reference/answer/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/answer/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/call/","title":"webPhone.call()","text":"<p>Initiates a phone call to a phone number and establishes a call session.</p>"},{"location":"reference/call/#sample","title":"Sample","text":"<pre><code>const callSession = await webPhone.call(callee, callerId);\n</code></pre>"},{"location":"reference/call/#inputs","title":"Inputs","text":"Parameter Description <code>callee</code> The phone number you want to call. Format is <code>16506668888</code>. <code>callerId</code> The phone number you want to display on the callee's phone. Format is <code>16506668888</code>. <p>You can't use any caller ID phone number that you desire. You are limited to a list of pre-registered caller IDs that you can retrieve from RingCentral using the list extension phone numbers API. You will need to filter the phone numbers returned by that API and only use the ones with the <code>CallerId</code> feature.</p> <pre><code>{\n  \"features\": [\n     ...,\n     \"CallerId\", \n     ...\n  ]\n}\n</code></pre>"},{"location":"reference/call/#outputs","title":"Outputs","text":"Parameter Description <code>callSession</code> A call session."},{"location":"reference/decline/","title":"callSession.decline()","text":"<p>This is reserved for inbound call sessions only.</p> <p>Decline an incoming call. Do not send it to voicemail.</p> <p>Declining an inbound call will not terminate the call session for the caller immediately. The caller will hear the ringback tone for a while until he/she hears \"I am sorry, no one is available to take your call. Thank you for calling. Goodbye.\" And the call will not reach your voicemail.</p>"},{"location":"reference/decline/#sample","title":"Sample","text":"<pre><code>await callSession.decline();\n</code></pre>"},{"location":"reference/decline/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/decline/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/dispose/","title":"webPhone.dispose()","text":"<p>This method properly disposes of a WebPhone instance so that an instance can be freed for use. There is a limit of five instances per extension.</p> <p>See also:</p> <ul> <li>Instances</li> </ul>"},{"location":"reference/dispose/#sample","title":"Sample","text":"<pre><code>await webPhone.dispose();\n</code></pre>"},{"location":"reference/dispose/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/dispose/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/flip/","title":"callSession.flip()","text":"<p>Call flipping refers to the ability to seamlessly transfer an active phone call from one device to another without interrupting the conversation.</p> <p>The most popular use case of call flip is to switch the current call to your other devices. Let's say you are talking to someone on your desktop, and you want to switch to your mobile phone. You can use call flip to achieve this.</p> <p>As soon as the flip starts, the remote peer will be put on hold and your target phone will receive a call. You answer the call, and then terminate the call on the originating device to complete the process.</p> <p>!!! note \"Flipping versus transferring\" Please also note that, this SDK allows you to flip the call to any phone number, not just your own phone numbers. But if it is not your number, we recommend you transfer the call instead of flipping the call.</p> <p>Sample response</p> <pre><code>{\n  \"code\": 0,\n  \"description\": \"Succeeded\",\n  \"number\": \"+16506668888\",\n  \"target\": \"16506668888\"\n}\n</code></pre> <p>Flipping a call is functionally similar to a cold transfer, with one small difference:</p> <ul> <li>after you initiate cold transfer, the current call session will auto end since   SIP server will send a \"BYE\" message to you.</li> <li>after you intiate a flip, the current call will not auto end, and you will   need to manually end it for the flip to complete.</li> </ul> <p>See also:</p> <ul> <li><code>transfer()</code></li> </ul>"},{"location":"reference/flip/#sample","title":"Sample","text":"<pre><code>const result = await callSession.flip(targetNumber);\n</code></pre>"},{"location":"reference/flip/#inputs","title":"Inputs","text":"Parameters Description <code>targetNumber</code> The phone number to flip the call to."},{"location":"reference/flip/#outputs","title":"Outputs","text":"Parameters Description <code>result</code> The response returned from the call. <code>result.code</code> The response code. A zero indicates success. <code>result.description</code> A string describing the result, e.g. \"succeeded\". <code>result.number</code> <code>result.target</code>"},{"location":"reference/forward/","title":"callSession.forward()","text":"<p>This is reserved for inbound call sessions only.</p> <p>For incoming calls, this will forward the call do a different number. This happens invisibily to the caller. This is different from a transfer that take effect on a call once answered.</p> <p>See also:</p> <ul> <li><code>transfer()</code></li> </ul>"},{"location":"reference/forward/#sample","title":"Sample","text":"<pre><code>await callSession.forward(targetNumber);\n</code></pre>"},{"location":"reference/forward/#inputs","title":"Inputs","text":"Parameters Description <code>targetNumber</code> The phone number to forward the caller to."},{"location":"reference/forward/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/hangup/","title":"callSession.hangup()","text":"<p>Terminates the existing call.</p>"},{"location":"reference/hangup/#sample","title":"Sample","text":"<pre><code>await callSession.hangup();\n</code></pre>"},{"location":"reference/hangup/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/hangup/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/hold/","title":"callSession.hold()","text":"<p>If you put the call on hold, the remote peer will hear hold music. Neither you nor the remote peer can hear each other. If you unhold the call, you and the remote peer can hear each other again.</p> <p>See also:</p> <ul> <li><code>unhold()</code></li> </ul>"},{"location":"reference/hold/#sample","title":"Sample","text":"<pre><code>await callSession.hold();\n</code></pre>"},{"location":"reference/hold/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/hold/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/mute/","title":"callSession.mute()","text":"<p>If you mute the call, the remote peer can't hear you. If you unmute the call, the remote peer can hear you again.</p> <p>See also:</p> <ul> <li><code>unmute()</code></li> </ul>"},{"location":"reference/mute/#sample","title":"Sample","text":"<pre><code>await callSession.mute();\n</code></pre>"},{"location":"reference/mute/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/mute/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/park/","title":"callSession.park()","text":"<p>Upon calling this method, the call session will be ended for you, and the remote peer will be put on hold and parked on an extension. You will be able to retrieve the parked call by dialing <code>*&lt;parked extension&gt;</code>. The extension the user is parked is returned in the response returned by the method.</p> <p>Sample response</p> <pre><code>{\n  \"code\": 0,\n  \"description\": \"Succeeded\",\n  \"park extension\": \"813\"\n}\n</code></pre> <p>Take the sample result above as an example, you can retrieve the parked call by dialing <code>*813</code>.</p>"},{"location":"reference/park/#sample","title":"Sample","text":"<pre><code>const result = await callSession.park();\n</code></pre>"},{"location":"reference/park/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/park/#outputs","title":"Outputs","text":"Parameters Description <code>result</code> The response received from parking the call. <code>result.code</code> The response code. A zero indicates success. <code>result.description</code> A string describing the result, e.g. \"succeeded\". <code>result.park extension</code> The extension the user was parked at."},{"location":"reference/reInvite/","title":"callSession.reInvite()","text":"<p>This is useful when an ongoing call becomes broken after you switch from one network to another. Let's say you are having a call with your friend and you switch from WiFi network to cellular. The call will become \"silent\". You can restore the call by invoking <code>callSession.reInvite()</code>.</p> <p>!!! tip \"Recovering from an outage is complex\" While this page discussing a single method related to recovering from an outage, it is not sufficient by itself. For example, if a network change, the WebSocket connection will also break - preventing your soft phone from received needed events from RingCentral. Please read our guide on recovering from a network issue.</p> <p>This method accepts an optional boolean argument, which defaults to <code>true</code>. A false value will result in the caller not being reconnected to the user upon recovery. For example, if the call was on hold, you want to recover the call but keep it on hold.</p> <p>!!! info \"Technical details\" <code>reInvite()</code> will generate new local SDP and do iceRestart. And after server replies with remote SDP, it will be set: <code>rtcPeerConnection.setRemoteDescription(remoteSDP)</code>. This is required because if network information changed, old SDPs won't work any more.</p> <p>See also:</p> <ul> <li>Recovering from an outage</li> </ul>"},{"location":"reference/reInvite/#sample","title":"Sample","text":"<pre><code>callSession.reInvite(false);\n</code></pre>"},{"location":"reference/reInvite/#inputs","title":"Inputs","text":"Parameters Description <code>connectCall</code> A boolean value (true or false) to indicate whether to reconnect the call to caller after recovery."},{"location":"reference/reInvite/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/reply/","title":"callSession.reply()","text":"<p>This is reserved for inbound call sessions only.</p> <p>When this method is called, the call session is terminated for the callee, but not for the caller. Instead the caller will hear a message, before being prompted to enter a number of their keypad. The content of the message is delivered via text-to-speech, with the source being the value of the <code>text</code> input variable. After reading the message to the caller, they will then hear several options:</p> <ul> <li>press 1 to repeat the message</li> <li>press 2 to leave a voicemail</li> <li>press 3 to reply with \"yes\"</li> <li>press 4 to reply with \"no\"</li> <li>press 5 to reply with \"urgent, please call immediately\"</li> <li>press 6 to to disconnect</li> </ul> <p>If the caller selects 5, they will then be prompted to enter a call back number.</p>"},{"location":"reference/reply/#sample","title":"Sample","text":"<pre><code>const response = await session.reply(\n  \"I am busy now, can I call you back later?\",\n);\nif (response.body.Sts === \"0\") {\n  const message = `${response.body.Phn} ${response.body.Nm}`;\n  let description = \"\";\n  switch (response.body.Resp) {\n    case \"1\":\n      description = \"Yes\";\n      break;\n    case \"2\":\n      description = \"No\";\n      break;\n    case \"3\":\n      description = `Urgent, please call ${response.body.ExtNfo} immediately!`;\n      break;\n    default:\n      break;\n  }\n  globalThis.notifier.info({\n    message, // who replied\n    description, // what replied\n    duration: 0,\n  });\n}\n</code></pre>"},{"location":"reference/reply/#inputs","title":"Inputs","text":"Parameter Description <code>text</code> The message to send to the caller."},{"location":"reference/reply/#outputs","title":"Outputs","text":"Parameter Description <code>response</code> The response returned by the SIP server. <code>response.body.Sts</code> If this property is equal to zero, then the caller responded to the prompt. The value they entered is stored in <code>Resp</code>. <code>response.body.Resp</code> The caller's response to the reply <code>text</code> prompt. <code>response.body.ExtNfo</code> If the caller pressed \"5\" indicating that the call is urgent and requests a call back, then this properly will hold the phone number they entered."},{"location":"reference/reply/#understanding-the-value-of-resp","title":"Understanding the value of <code>Resp</code>","text":"<code>Resp</code> Meaning <code>1</code> it means that the caller replied with \"yes\" (they pressed 3) <code>2</code> it means that the caller replied with \"no\" (they pressed 4) <code>3</code> it means that the caller replied with \"urgent, please call [number] immediately\". (they pressed 5)"},{"location":"reference/sendDtmf/","title":"callSession.sendDtmf()","text":"<p>DTMF stands for Dual-Tone Multi-Frequency. It's the system used for telephone signaling over analog telephone lines in the voice-frequency band. DTMF allows the user to dial numbers and send commands by pressing keys on a telephone keypad.</p> <p>How It Works:</p> <ul> <li>Each key on the keypad generates two simultaneous tones\u2014one from a   high-frequency group and one from a low-frequency group.</li> <li>These combined tones are unique to each key and can be decoded by the   telephone system to identify which button was pressed.</li> </ul> <p><code>ABCD</code> are less commonly used but are part of the DTMF standard. They were originally intended for special signaling in military and network control systems.</p> <p>This method is used to send a DTMF. However, receving DTMF is not supported, as it is not supported by WebRTC.</p>"},{"location":"reference/sendDtmf/#sample","title":"Sample","text":"<pre><code>await callSession.sendDtmf(dtmf);\n</code></pre>"},{"location":"reference/sendDtmf/#inputs","title":"Inputs","text":"Parameters Description <code>dtmf</code> A string containing only the following characters: <code>0123456789*#ABCD</code>."},{"location":"reference/sendDtmf/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/startRecording/","title":"callSession.startRecording()","text":"<p>Just as the method name says, this will cause a call recording to be started.</p> <p>See also:</p> <ul> <li><code>stopRecording</code></li> </ul>"},{"location":"reference/startRecording/#sample","title":"Sample","text":"<pre><code>await callSession.startRecording();\n</code></pre>"},{"location":"reference/startRecording/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/startRecording/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/startReply/","title":"callSession.startReply()","text":"<p>This is reserved for inbound call sessions only.</p> <p>You can optionally tell the server that the user has started replying the call. The server will give the user more time to edit the reply message before ending the call or redirecting the call to voicemail.</p> <p>See also:</p> <ul> <li><code>reply()</code></li> </ul>"},{"location":"reference/startReply/#sample","title":"Sample","text":"<pre><code>await callSession.startReply();\n</code></pre>"},{"location":"reference/startReply/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/startReply/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/stopRecording/","title":"callSession.stopRecording()","text":"<p>Just as the method name says, this will cause a call recording to be stopped or paused.</p> <p>See also:</p> <ul> <li><code>startRecording</code></li> </ul>"},{"location":"reference/stopRecording/#sample","title":"Sample","text":"<pre><code>await callSession.stopRecording();\n</code></pre>"},{"location":"reference/stopRecording/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/stopRecording/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/toVoicemail/","title":"callSession.toVoicemail()","text":"<p>This is reserved for inbound call sessions only.</p> <p>When called, the current call will not be answered, and instead be transfered to the user's voicemail to leave a message.</p>"},{"location":"reference/toVoicemail/#sample","title":"Sample","text":"<pre><code>await callSession.toVoicemail();\n</code></pre>"},{"location":"reference/toVoicemail/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/toVoicemail/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/transfer/","title":"callSession.transfer()","text":"<p>This method executes a cold or blind transfer. This is a type of call transfer in which the caller is transferred immediately to the destination with no prior screening.</p> <p>See also:</p> <ul> <li><code>warmTrasnfer()</code></li> </ul>"},{"location":"reference/transfer/#sample","title":"Sample","text":"<pre><code>await callSession.transfer(transferToNumber);\n</code></pre>"},{"location":"reference/transfer/#inputs","title":"Inputs","text":"Parameter Description <code>transferToNumber</code> The phone number destination the transferee will be sent."},{"location":"reference/transfer/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/unhold/","title":"callSession.unhold()","text":"<p>If you put the call on hold, the remote peer will hear hold music. Neither you nor the remote peer can hear each other. If you unhold the call, you and the remote peer can hear each other again.</p> <p>See also:</p> <ul> <li><code>hold()</code></li> </ul>"},{"location":"reference/unhold/#sample","title":"Sample","text":"<pre><code>await callSession.unhold();\n</code></pre>"},{"location":"reference/unhold/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/unhold/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/unmute/","title":"callSession.unmute()","text":"<p>If you mute the call, the remote peer can't hear you. If you unmute the call, the remote peer can hear you again.</p> <p>See also:</p> <ul> <li><code>mute()</code></li> </ul>"},{"location":"reference/unmute/#sample","title":"Sample","text":"<pre><code>await callSession.unmute();\n</code></pre>"},{"location":"reference/unmute/#inputs","title":"Inputs","text":"<p>None.</p>"},{"location":"reference/unmute/#outputs","title":"Outputs","text":"<p>None.</p>"},{"location":"reference/warmTransfer/","title":"callSession.warmTransfer()","text":"<p>A warm transfer is a type of call transfer in which the original caller is first introduced or announced to the next party (usually another agent or department) before the handoff is completed. This typically involves the first agent speaking briefly with the next agent to explain the context of the call, then connecting all parties together or passing the caller along.</p> <p>When this method is called, the current call session is put on hold. A new call session is then created with the <code>transferToNumber</code>. The agent is now free to talk to the person who will be receiving the call. The app can execute one two callbacks to either complete the transfer or return to the previous state (cancel).</p> <p>See also:</p> <ul> <li><code>transfer()</code></li> </ul>"},{"location":"reference/warmTransfer/#sample","title":"Sample","text":"<pre><code>const { complete, cancel } = await callSession.warmTransfer(transferToNumber);\n</code></pre>"},{"location":"reference/warmTransfer/#inputs","title":"Inputs","text":"Parameter Description <code>transferToNumber</code> The phone number destination the transferee will be sent."},{"location":"reference/warmTransfer/#outputs","title":"Outputs","text":"Parameter Description <code>complete()</code> A callback to be executed when you wish to complete the transfer to the destination. <code>cancel()</code> A callback to cancel the transfer, and not connecting the two parties."}]}